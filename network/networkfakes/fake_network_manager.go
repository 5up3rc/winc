// Code generated by counterfeiter. DO NOT EDIT.
package networkfakes

import (
	"sync"

	"code.cloudfoundry.org/winc/hcsclient"
	"code.cloudfoundry.org/winc/network"
	"github.com/Microsoft/hcsshim"
)

type FakeNetworkManager struct {
	AttachEndpointToConfigStub        func(config hcsshim.ContainerConfig, containerID string) (hcsshim.ContainerConfig, error)
	attachEndpointToConfigMutex       sync.RWMutex
	attachEndpointToConfigArgsForCall []struct {
		config      hcsshim.ContainerConfig
		containerID string
	}
	attachEndpointToConfigReturns struct {
		result1 hcsshim.ContainerConfig
		result2 error
	}
	attachEndpointToConfigReturnsOnCall map[int]struct {
		result1 hcsshim.ContainerConfig
		result2 error
	}
	DeleteContainerEndpointsStub        func(container hcsclient.Container, containerID string) error
	deleteContainerEndpointsMutex       sync.RWMutex
	deleteContainerEndpointsArgsForCall []struct {
		container   hcsclient.Container
		containerID string
	}
	deleteContainerEndpointsReturns struct {
		result1 error
	}
	deleteContainerEndpointsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteEndpointsByIdStub        func(ids []string, containerID string) error
	deleteEndpointsByIdMutex       sync.RWMutex
	deleteEndpointsByIdArgsForCall []struct {
		ids         []string
		containerID string
	}
	deleteEndpointsByIdReturns struct {
		result1 error
	}
	deleteEndpointsByIdReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNetworkManager) AttachEndpointToConfig(config hcsshim.ContainerConfig, containerID string) (hcsshim.ContainerConfig, error) {
	fake.attachEndpointToConfigMutex.Lock()
	ret, specificReturn := fake.attachEndpointToConfigReturnsOnCall[len(fake.attachEndpointToConfigArgsForCall)]
	fake.attachEndpointToConfigArgsForCall = append(fake.attachEndpointToConfigArgsForCall, struct {
		config      hcsshim.ContainerConfig
		containerID string
	}{config, containerID})
	fake.recordInvocation("AttachEndpointToConfig", []interface{}{config, containerID})
	fake.attachEndpointToConfigMutex.Unlock()
	if fake.AttachEndpointToConfigStub != nil {
		return fake.AttachEndpointToConfigStub(config, containerID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.attachEndpointToConfigReturns.result1, fake.attachEndpointToConfigReturns.result2
}

func (fake *FakeNetworkManager) AttachEndpointToConfigCallCount() int {
	fake.attachEndpointToConfigMutex.RLock()
	defer fake.attachEndpointToConfigMutex.RUnlock()
	return len(fake.attachEndpointToConfigArgsForCall)
}

func (fake *FakeNetworkManager) AttachEndpointToConfigArgsForCall(i int) (hcsshim.ContainerConfig, string) {
	fake.attachEndpointToConfigMutex.RLock()
	defer fake.attachEndpointToConfigMutex.RUnlock()
	return fake.attachEndpointToConfigArgsForCall[i].config, fake.attachEndpointToConfigArgsForCall[i].containerID
}

func (fake *FakeNetworkManager) AttachEndpointToConfigReturns(result1 hcsshim.ContainerConfig, result2 error) {
	fake.AttachEndpointToConfigStub = nil
	fake.attachEndpointToConfigReturns = struct {
		result1 hcsshim.ContainerConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AttachEndpointToConfigReturnsOnCall(i int, result1 hcsshim.ContainerConfig, result2 error) {
	fake.AttachEndpointToConfigStub = nil
	if fake.attachEndpointToConfigReturnsOnCall == nil {
		fake.attachEndpointToConfigReturnsOnCall = make(map[int]struct {
			result1 hcsshim.ContainerConfig
			result2 error
		})
	}
	fake.attachEndpointToConfigReturnsOnCall[i] = struct {
		result1 hcsshim.ContainerConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) DeleteContainerEndpoints(container hcsclient.Container, containerID string) error {
	fake.deleteContainerEndpointsMutex.Lock()
	ret, specificReturn := fake.deleteContainerEndpointsReturnsOnCall[len(fake.deleteContainerEndpointsArgsForCall)]
	fake.deleteContainerEndpointsArgsForCall = append(fake.deleteContainerEndpointsArgsForCall, struct {
		container   hcsclient.Container
		containerID string
	}{container, containerID})
	fake.recordInvocation("DeleteContainerEndpoints", []interface{}{container, containerID})
	fake.deleteContainerEndpointsMutex.Unlock()
	if fake.DeleteContainerEndpointsStub != nil {
		return fake.DeleteContainerEndpointsStub(container, containerID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteContainerEndpointsReturns.result1
}

func (fake *FakeNetworkManager) DeleteContainerEndpointsCallCount() int {
	fake.deleteContainerEndpointsMutex.RLock()
	defer fake.deleteContainerEndpointsMutex.RUnlock()
	return len(fake.deleteContainerEndpointsArgsForCall)
}

func (fake *FakeNetworkManager) DeleteContainerEndpointsArgsForCall(i int) (hcsclient.Container, string) {
	fake.deleteContainerEndpointsMutex.RLock()
	defer fake.deleteContainerEndpointsMutex.RUnlock()
	return fake.deleteContainerEndpointsArgsForCall[i].container, fake.deleteContainerEndpointsArgsForCall[i].containerID
}

func (fake *FakeNetworkManager) DeleteContainerEndpointsReturns(result1 error) {
	fake.DeleteContainerEndpointsStub = nil
	fake.deleteContainerEndpointsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DeleteContainerEndpointsReturnsOnCall(i int, result1 error) {
	fake.DeleteContainerEndpointsStub = nil
	if fake.deleteContainerEndpointsReturnsOnCall == nil {
		fake.deleteContainerEndpointsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteContainerEndpointsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DeleteEndpointsById(ids []string, containerID string) error {
	var idsCopy []string
	if ids != nil {
		idsCopy = make([]string, len(ids))
		copy(idsCopy, ids)
	}
	fake.deleteEndpointsByIdMutex.Lock()
	ret, specificReturn := fake.deleteEndpointsByIdReturnsOnCall[len(fake.deleteEndpointsByIdArgsForCall)]
	fake.deleteEndpointsByIdArgsForCall = append(fake.deleteEndpointsByIdArgsForCall, struct {
		ids         []string
		containerID string
	}{idsCopy, containerID})
	fake.recordInvocation("DeleteEndpointsById", []interface{}{idsCopy, containerID})
	fake.deleteEndpointsByIdMutex.Unlock()
	if fake.DeleteEndpointsByIdStub != nil {
		return fake.DeleteEndpointsByIdStub(ids, containerID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteEndpointsByIdReturns.result1
}

func (fake *FakeNetworkManager) DeleteEndpointsByIdCallCount() int {
	fake.deleteEndpointsByIdMutex.RLock()
	defer fake.deleteEndpointsByIdMutex.RUnlock()
	return len(fake.deleteEndpointsByIdArgsForCall)
}

func (fake *FakeNetworkManager) DeleteEndpointsByIdArgsForCall(i int) ([]string, string) {
	fake.deleteEndpointsByIdMutex.RLock()
	defer fake.deleteEndpointsByIdMutex.RUnlock()
	return fake.deleteEndpointsByIdArgsForCall[i].ids, fake.deleteEndpointsByIdArgsForCall[i].containerID
}

func (fake *FakeNetworkManager) DeleteEndpointsByIdReturns(result1 error) {
	fake.DeleteEndpointsByIdStub = nil
	fake.deleteEndpointsByIdReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DeleteEndpointsByIdReturnsOnCall(i int, result1 error) {
	fake.DeleteEndpointsByIdStub = nil
	if fake.deleteEndpointsByIdReturnsOnCall == nil {
		fake.deleteEndpointsByIdReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteEndpointsByIdReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachEndpointToConfigMutex.RLock()
	defer fake.attachEndpointToConfigMutex.RUnlock()
	fake.deleteContainerEndpointsMutex.RLock()
	defer fake.deleteContainerEndpointsMutex.RUnlock()
	fake.deleteEndpointsByIdMutex.RLock()
	defer fake.deleteEndpointsByIdMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNetworkManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ network.NetworkManager = new(FakeNetworkManager)
