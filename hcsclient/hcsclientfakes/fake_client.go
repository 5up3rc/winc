// Code generated by counterfeiter. DO NOT EDIT.
package hcsclientfakes

import (
	"sync"

	"code.cloudfoundry.org/winc/hcsclient"
	"github.com/Microsoft/hcsshim"
)

type FakeClient struct {
	GetContainersStub        func(q hcsshim.ComputeSystemQuery) ([]hcsshim.ContainerProperties, error)
	getContainersMutex       sync.RWMutex
	getContainersArgsForCall []struct {
		q hcsshim.ComputeSystemQuery
	}
	getContainersReturns struct {
		result1 []hcsshim.ContainerProperties
		result2 error
	}
	getContainersReturnsOnCall map[int]struct {
		result1 []hcsshim.ContainerProperties
		result2 error
	}
	NameToGuidStub        func(name string) (hcsshim.GUID, error)
	nameToGuidMutex       sync.RWMutex
	nameToGuidArgsForCall []struct {
		name string
	}
	nameToGuidReturns struct {
		result1 hcsshim.GUID
		result2 error
	}
	nameToGuidReturnsOnCall map[int]struct {
		result1 hcsshim.GUID
		result2 error
	}
	GetLayerMountPathStub        func(info hcsshim.DriverInfo, id string) (string, error)
	getLayerMountPathMutex       sync.RWMutex
	getLayerMountPathArgsForCall []struct {
		info hcsshim.DriverInfo
		id   string
	}
	getLayerMountPathReturns struct {
		result1 string
		result2 error
	}
	getLayerMountPathReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CreateContainerStub        func(id string, config *hcsshim.ContainerConfig) (hcsshim.Container, error)
	createContainerMutex       sync.RWMutex
	createContainerArgsForCall []struct {
		id     string
		config *hcsshim.ContainerConfig
	}
	createContainerReturns struct {
		result1 hcsshim.Container
		result2 error
	}
	createContainerReturnsOnCall map[int]struct {
		result1 hcsshim.Container
		result2 error
	}
	OpenContainerStub        func(id string) (hcsshim.Container, error)
	openContainerMutex       sync.RWMutex
	openContainerArgsForCall []struct {
		id string
	}
	openContainerReturns struct {
		result1 hcsshim.Container
		result2 error
	}
	openContainerReturnsOnCall map[int]struct {
		result1 hcsshim.Container
		result2 error
	}
	IsPendingStub        func(err error) bool
	isPendingMutex       sync.RWMutex
	isPendingArgsForCall []struct {
		err error
	}
	isPendingReturns struct {
		result1 bool
	}
	isPendingReturnsOnCall map[int]struct {
		result1 bool
	}
	CreateSandboxLayerStub        func(info hcsshim.DriverInfo, layerId, parentId string, parentLayerPaths []string) error
	createSandboxLayerMutex       sync.RWMutex
	createSandboxLayerArgsForCall []struct {
		info             hcsshim.DriverInfo
		layerId          string
		parentId         string
		parentLayerPaths []string
	}
	createSandboxLayerReturns struct {
		result1 error
	}
	createSandboxLayerReturnsOnCall map[int]struct {
		result1 error
	}
	ActivateLayerStub        func(info hcsshim.DriverInfo, id string) error
	activateLayerMutex       sync.RWMutex
	activateLayerArgsForCall []struct {
		info hcsshim.DriverInfo
		id   string
	}
	activateLayerReturns struct {
		result1 error
	}
	activateLayerReturnsOnCall map[int]struct {
		result1 error
	}
	PrepareLayerStub        func(info hcsshim.DriverInfo, layerId string, parentLayerPaths []string) error
	prepareLayerMutex       sync.RWMutex
	prepareLayerArgsForCall []struct {
		info             hcsshim.DriverInfo
		layerId          string
		parentLayerPaths []string
	}
	prepareLayerReturns struct {
		result1 error
	}
	prepareLayerReturnsOnCall map[int]struct {
		result1 error
	}
	UnprepareLayerStub        func(info hcsshim.DriverInfo, layerId string) error
	unprepareLayerMutex       sync.RWMutex
	unprepareLayerArgsForCall []struct {
		info    hcsshim.DriverInfo
		layerId string
	}
	unprepareLayerReturns struct {
		result1 error
	}
	unprepareLayerReturnsOnCall map[int]struct {
		result1 error
	}
	DeactivateLayerStub        func(info hcsshim.DriverInfo, id string) error
	deactivateLayerMutex       sync.RWMutex
	deactivateLayerArgsForCall []struct {
		info hcsshim.DriverInfo
		id   string
	}
	deactivateLayerReturns struct {
		result1 error
	}
	deactivateLayerReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyLayerStub        func(info hcsshim.DriverInfo, id string) error
	destroyLayerMutex       sync.RWMutex
	destroyLayerArgsForCall []struct {
		info hcsshim.DriverInfo
		id   string
	}
	destroyLayerReturns struct {
		result1 error
	}
	destroyLayerReturnsOnCall map[int]struct {
		result1 error
	}
	GetContainerPropertiesStub        func(id string) (hcsshim.ContainerProperties, error)
	getContainerPropertiesMutex       sync.RWMutex
	getContainerPropertiesArgsForCall []struct {
		id string
	}
	getContainerPropertiesReturns struct {
		result1 hcsshim.ContainerProperties
		result2 error
	}
	getContainerPropertiesReturnsOnCall map[int]struct {
		result1 hcsshim.ContainerProperties
		result2 error
	}
	HNSListNetworkRequestStub        func() ([]hcsshim.HNSNetwork, error)
	hNSListNetworkRequestMutex       sync.RWMutex
	hNSListNetworkRequestArgsForCall []struct{}
	hNSListNetworkRequestReturns     struct {
		result1 []hcsshim.HNSNetwork
		result2 error
	}
	hNSListNetworkRequestReturnsOnCall map[int]struct {
		result1 []hcsshim.HNSNetwork
		result2 error
	}
	GetHNSEndpointByIDStub        func(id string) (*hcsshim.HNSEndpoint, error)
	getHNSEndpointByIDMutex       sync.RWMutex
	getHNSEndpointByIDArgsForCall []struct {
		id string
	}
	getHNSEndpointByIDReturns struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}
	getHNSEndpointByIDReturnsOnCall map[int]struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}
	CreateEndpointStub        func(*hcsshim.HNSEndpoint) (*hcsshim.HNSEndpoint, error)
	createEndpointMutex       sync.RWMutex
	createEndpointArgsForCall []struct {
		arg1 *hcsshim.HNSEndpoint
	}
	createEndpointReturns struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}
	createEndpointReturnsOnCall map[int]struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}
	DeleteEndpointStub        func(*hcsshim.HNSEndpoint) (*hcsshim.HNSEndpoint, error)
	deleteEndpointMutex       sync.RWMutex
	deleteEndpointArgsForCall []struct {
		arg1 *hcsshim.HNSEndpoint
	}
	deleteEndpointReturns struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}
	deleteEndpointReturnsOnCall map[int]struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}
	CreateNetworkStub        func(*hcsshim.HNSNetwork) (*hcsshim.HNSNetwork, error)
	createNetworkMutex       sync.RWMutex
	createNetworkArgsForCall []struct {
		arg1 *hcsshim.HNSNetwork
	}
	createNetworkReturns struct {
		result1 *hcsshim.HNSNetwork
		result2 error
	}
	createNetworkReturnsOnCall map[int]struct {
		result1 *hcsshim.HNSNetwork
		result2 error
	}
	DeleteNetworkStub        func(*hcsshim.HNSNetwork) (*hcsshim.HNSNetwork, error)
	deleteNetworkMutex       sync.RWMutex
	deleteNetworkArgsForCall []struct {
		arg1 *hcsshim.HNSNetwork
	}
	deleteNetworkReturns struct {
		result1 *hcsshim.HNSNetwork
		result2 error
	}
	deleteNetworkReturnsOnCall map[int]struct {
		result1 *hcsshim.HNSNetwork
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) GetContainers(q hcsshim.ComputeSystemQuery) ([]hcsshim.ContainerProperties, error) {
	fake.getContainersMutex.Lock()
	ret, specificReturn := fake.getContainersReturnsOnCall[len(fake.getContainersArgsForCall)]
	fake.getContainersArgsForCall = append(fake.getContainersArgsForCall, struct {
		q hcsshim.ComputeSystemQuery
	}{q})
	fake.recordInvocation("GetContainers", []interface{}{q})
	fake.getContainersMutex.Unlock()
	if fake.GetContainersStub != nil {
		return fake.GetContainersStub(q)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getContainersReturns.result1, fake.getContainersReturns.result2
}

func (fake *FakeClient) GetContainersCallCount() int {
	fake.getContainersMutex.RLock()
	defer fake.getContainersMutex.RUnlock()
	return len(fake.getContainersArgsForCall)
}

func (fake *FakeClient) GetContainersArgsForCall(i int) hcsshim.ComputeSystemQuery {
	fake.getContainersMutex.RLock()
	defer fake.getContainersMutex.RUnlock()
	return fake.getContainersArgsForCall[i].q
}

func (fake *FakeClient) GetContainersReturns(result1 []hcsshim.ContainerProperties, result2 error) {
	fake.GetContainersStub = nil
	fake.getContainersReturns = struct {
		result1 []hcsshim.ContainerProperties
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetContainersReturnsOnCall(i int, result1 []hcsshim.ContainerProperties, result2 error) {
	fake.GetContainersStub = nil
	if fake.getContainersReturnsOnCall == nil {
		fake.getContainersReturnsOnCall = make(map[int]struct {
			result1 []hcsshim.ContainerProperties
			result2 error
		})
	}
	fake.getContainersReturnsOnCall[i] = struct {
		result1 []hcsshim.ContainerProperties
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) NameToGuid(name string) (hcsshim.GUID, error) {
	fake.nameToGuidMutex.Lock()
	ret, specificReturn := fake.nameToGuidReturnsOnCall[len(fake.nameToGuidArgsForCall)]
	fake.nameToGuidArgsForCall = append(fake.nameToGuidArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NameToGuid", []interface{}{name})
	fake.nameToGuidMutex.Unlock()
	if fake.NameToGuidStub != nil {
		return fake.NameToGuidStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nameToGuidReturns.result1, fake.nameToGuidReturns.result2
}

func (fake *FakeClient) NameToGuidCallCount() int {
	fake.nameToGuidMutex.RLock()
	defer fake.nameToGuidMutex.RUnlock()
	return len(fake.nameToGuidArgsForCall)
}

func (fake *FakeClient) NameToGuidArgsForCall(i int) string {
	fake.nameToGuidMutex.RLock()
	defer fake.nameToGuidMutex.RUnlock()
	return fake.nameToGuidArgsForCall[i].name
}

func (fake *FakeClient) NameToGuidReturns(result1 hcsshim.GUID, result2 error) {
	fake.NameToGuidStub = nil
	fake.nameToGuidReturns = struct {
		result1 hcsshim.GUID
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) NameToGuidReturnsOnCall(i int, result1 hcsshim.GUID, result2 error) {
	fake.NameToGuidStub = nil
	if fake.nameToGuidReturnsOnCall == nil {
		fake.nameToGuidReturnsOnCall = make(map[int]struct {
			result1 hcsshim.GUID
			result2 error
		})
	}
	fake.nameToGuidReturnsOnCall[i] = struct {
		result1 hcsshim.GUID
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetLayerMountPath(info hcsshim.DriverInfo, id string) (string, error) {
	fake.getLayerMountPathMutex.Lock()
	ret, specificReturn := fake.getLayerMountPathReturnsOnCall[len(fake.getLayerMountPathArgsForCall)]
	fake.getLayerMountPathArgsForCall = append(fake.getLayerMountPathArgsForCall, struct {
		info hcsshim.DriverInfo
		id   string
	}{info, id})
	fake.recordInvocation("GetLayerMountPath", []interface{}{info, id})
	fake.getLayerMountPathMutex.Unlock()
	if fake.GetLayerMountPathStub != nil {
		return fake.GetLayerMountPathStub(info, id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getLayerMountPathReturns.result1, fake.getLayerMountPathReturns.result2
}

func (fake *FakeClient) GetLayerMountPathCallCount() int {
	fake.getLayerMountPathMutex.RLock()
	defer fake.getLayerMountPathMutex.RUnlock()
	return len(fake.getLayerMountPathArgsForCall)
}

func (fake *FakeClient) GetLayerMountPathArgsForCall(i int) (hcsshim.DriverInfo, string) {
	fake.getLayerMountPathMutex.RLock()
	defer fake.getLayerMountPathMutex.RUnlock()
	return fake.getLayerMountPathArgsForCall[i].info, fake.getLayerMountPathArgsForCall[i].id
}

func (fake *FakeClient) GetLayerMountPathReturns(result1 string, result2 error) {
	fake.GetLayerMountPathStub = nil
	fake.getLayerMountPathReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetLayerMountPathReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetLayerMountPathStub = nil
	if fake.getLayerMountPathReturnsOnCall == nil {
		fake.getLayerMountPathReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getLayerMountPathReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateContainer(id string, config *hcsshim.ContainerConfig) (hcsshim.Container, error) {
	fake.createContainerMutex.Lock()
	ret, specificReturn := fake.createContainerReturnsOnCall[len(fake.createContainerArgsForCall)]
	fake.createContainerArgsForCall = append(fake.createContainerArgsForCall, struct {
		id     string
		config *hcsshim.ContainerConfig
	}{id, config})
	fake.recordInvocation("CreateContainer", []interface{}{id, config})
	fake.createContainerMutex.Unlock()
	if fake.CreateContainerStub != nil {
		return fake.CreateContainerStub(id, config)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createContainerReturns.result1, fake.createContainerReturns.result2
}

func (fake *FakeClient) CreateContainerCallCount() int {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	return len(fake.createContainerArgsForCall)
}

func (fake *FakeClient) CreateContainerArgsForCall(i int) (string, *hcsshim.ContainerConfig) {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	return fake.createContainerArgsForCall[i].id, fake.createContainerArgsForCall[i].config
}

func (fake *FakeClient) CreateContainerReturns(result1 hcsshim.Container, result2 error) {
	fake.CreateContainerStub = nil
	fake.createContainerReturns = struct {
		result1 hcsshim.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateContainerReturnsOnCall(i int, result1 hcsshim.Container, result2 error) {
	fake.CreateContainerStub = nil
	if fake.createContainerReturnsOnCall == nil {
		fake.createContainerReturnsOnCall = make(map[int]struct {
			result1 hcsshim.Container
			result2 error
		})
	}
	fake.createContainerReturnsOnCall[i] = struct {
		result1 hcsshim.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OpenContainer(id string) (hcsshim.Container, error) {
	fake.openContainerMutex.Lock()
	ret, specificReturn := fake.openContainerReturnsOnCall[len(fake.openContainerArgsForCall)]
	fake.openContainerArgsForCall = append(fake.openContainerArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("OpenContainer", []interface{}{id})
	fake.openContainerMutex.Unlock()
	if fake.OpenContainerStub != nil {
		return fake.OpenContainerStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openContainerReturns.result1, fake.openContainerReturns.result2
}

func (fake *FakeClient) OpenContainerCallCount() int {
	fake.openContainerMutex.RLock()
	defer fake.openContainerMutex.RUnlock()
	return len(fake.openContainerArgsForCall)
}

func (fake *FakeClient) OpenContainerArgsForCall(i int) string {
	fake.openContainerMutex.RLock()
	defer fake.openContainerMutex.RUnlock()
	return fake.openContainerArgsForCall[i].id
}

func (fake *FakeClient) OpenContainerReturns(result1 hcsshim.Container, result2 error) {
	fake.OpenContainerStub = nil
	fake.openContainerReturns = struct {
		result1 hcsshim.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OpenContainerReturnsOnCall(i int, result1 hcsshim.Container, result2 error) {
	fake.OpenContainerStub = nil
	if fake.openContainerReturnsOnCall == nil {
		fake.openContainerReturnsOnCall = make(map[int]struct {
			result1 hcsshim.Container
			result2 error
		})
	}
	fake.openContainerReturnsOnCall[i] = struct {
		result1 hcsshim.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) IsPending(err error) bool {
	fake.isPendingMutex.Lock()
	ret, specificReturn := fake.isPendingReturnsOnCall[len(fake.isPendingArgsForCall)]
	fake.isPendingArgsForCall = append(fake.isPendingArgsForCall, struct {
		err error
	}{err})
	fake.recordInvocation("IsPending", []interface{}{err})
	fake.isPendingMutex.Unlock()
	if fake.IsPendingStub != nil {
		return fake.IsPendingStub(err)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isPendingReturns.result1
}

func (fake *FakeClient) IsPendingCallCount() int {
	fake.isPendingMutex.RLock()
	defer fake.isPendingMutex.RUnlock()
	return len(fake.isPendingArgsForCall)
}

func (fake *FakeClient) IsPendingArgsForCall(i int) error {
	fake.isPendingMutex.RLock()
	defer fake.isPendingMutex.RUnlock()
	return fake.isPendingArgsForCall[i].err
}

func (fake *FakeClient) IsPendingReturns(result1 bool) {
	fake.IsPendingStub = nil
	fake.isPendingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) IsPendingReturnsOnCall(i int, result1 bool) {
	fake.IsPendingStub = nil
	if fake.isPendingReturnsOnCall == nil {
		fake.isPendingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isPendingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) CreateSandboxLayer(info hcsshim.DriverInfo, layerId string, parentId string, parentLayerPaths []string) error {
	var parentLayerPathsCopy []string
	if parentLayerPaths != nil {
		parentLayerPathsCopy = make([]string, len(parentLayerPaths))
		copy(parentLayerPathsCopy, parentLayerPaths)
	}
	fake.createSandboxLayerMutex.Lock()
	ret, specificReturn := fake.createSandboxLayerReturnsOnCall[len(fake.createSandboxLayerArgsForCall)]
	fake.createSandboxLayerArgsForCall = append(fake.createSandboxLayerArgsForCall, struct {
		info             hcsshim.DriverInfo
		layerId          string
		parentId         string
		parentLayerPaths []string
	}{info, layerId, parentId, parentLayerPathsCopy})
	fake.recordInvocation("CreateSandboxLayer", []interface{}{info, layerId, parentId, parentLayerPathsCopy})
	fake.createSandboxLayerMutex.Unlock()
	if fake.CreateSandboxLayerStub != nil {
		return fake.CreateSandboxLayerStub(info, layerId, parentId, parentLayerPaths)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createSandboxLayerReturns.result1
}

func (fake *FakeClient) CreateSandboxLayerCallCount() int {
	fake.createSandboxLayerMutex.RLock()
	defer fake.createSandboxLayerMutex.RUnlock()
	return len(fake.createSandboxLayerArgsForCall)
}

func (fake *FakeClient) CreateSandboxLayerArgsForCall(i int) (hcsshim.DriverInfo, string, string, []string) {
	fake.createSandboxLayerMutex.RLock()
	defer fake.createSandboxLayerMutex.RUnlock()
	return fake.createSandboxLayerArgsForCall[i].info, fake.createSandboxLayerArgsForCall[i].layerId, fake.createSandboxLayerArgsForCall[i].parentId, fake.createSandboxLayerArgsForCall[i].parentLayerPaths
}

func (fake *FakeClient) CreateSandboxLayerReturns(result1 error) {
	fake.CreateSandboxLayerStub = nil
	fake.createSandboxLayerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateSandboxLayerReturnsOnCall(i int, result1 error) {
	fake.CreateSandboxLayerStub = nil
	if fake.createSandboxLayerReturnsOnCall == nil {
		fake.createSandboxLayerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createSandboxLayerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ActivateLayer(info hcsshim.DriverInfo, id string) error {
	fake.activateLayerMutex.Lock()
	ret, specificReturn := fake.activateLayerReturnsOnCall[len(fake.activateLayerArgsForCall)]
	fake.activateLayerArgsForCall = append(fake.activateLayerArgsForCall, struct {
		info hcsshim.DriverInfo
		id   string
	}{info, id})
	fake.recordInvocation("ActivateLayer", []interface{}{info, id})
	fake.activateLayerMutex.Unlock()
	if fake.ActivateLayerStub != nil {
		return fake.ActivateLayerStub(info, id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.activateLayerReturns.result1
}

func (fake *FakeClient) ActivateLayerCallCount() int {
	fake.activateLayerMutex.RLock()
	defer fake.activateLayerMutex.RUnlock()
	return len(fake.activateLayerArgsForCall)
}

func (fake *FakeClient) ActivateLayerArgsForCall(i int) (hcsshim.DriverInfo, string) {
	fake.activateLayerMutex.RLock()
	defer fake.activateLayerMutex.RUnlock()
	return fake.activateLayerArgsForCall[i].info, fake.activateLayerArgsForCall[i].id
}

func (fake *FakeClient) ActivateLayerReturns(result1 error) {
	fake.ActivateLayerStub = nil
	fake.activateLayerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ActivateLayerReturnsOnCall(i int, result1 error) {
	fake.ActivateLayerStub = nil
	if fake.activateLayerReturnsOnCall == nil {
		fake.activateLayerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.activateLayerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PrepareLayer(info hcsshim.DriverInfo, layerId string, parentLayerPaths []string) error {
	var parentLayerPathsCopy []string
	if parentLayerPaths != nil {
		parentLayerPathsCopy = make([]string, len(parentLayerPaths))
		copy(parentLayerPathsCopy, parentLayerPaths)
	}
	fake.prepareLayerMutex.Lock()
	ret, specificReturn := fake.prepareLayerReturnsOnCall[len(fake.prepareLayerArgsForCall)]
	fake.prepareLayerArgsForCall = append(fake.prepareLayerArgsForCall, struct {
		info             hcsshim.DriverInfo
		layerId          string
		parentLayerPaths []string
	}{info, layerId, parentLayerPathsCopy})
	fake.recordInvocation("PrepareLayer", []interface{}{info, layerId, parentLayerPathsCopy})
	fake.prepareLayerMutex.Unlock()
	if fake.PrepareLayerStub != nil {
		return fake.PrepareLayerStub(info, layerId, parentLayerPaths)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.prepareLayerReturns.result1
}

func (fake *FakeClient) PrepareLayerCallCount() int {
	fake.prepareLayerMutex.RLock()
	defer fake.prepareLayerMutex.RUnlock()
	return len(fake.prepareLayerArgsForCall)
}

func (fake *FakeClient) PrepareLayerArgsForCall(i int) (hcsshim.DriverInfo, string, []string) {
	fake.prepareLayerMutex.RLock()
	defer fake.prepareLayerMutex.RUnlock()
	return fake.prepareLayerArgsForCall[i].info, fake.prepareLayerArgsForCall[i].layerId, fake.prepareLayerArgsForCall[i].parentLayerPaths
}

func (fake *FakeClient) PrepareLayerReturns(result1 error) {
	fake.PrepareLayerStub = nil
	fake.prepareLayerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PrepareLayerReturnsOnCall(i int, result1 error) {
	fake.PrepareLayerStub = nil
	if fake.prepareLayerReturnsOnCall == nil {
		fake.prepareLayerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.prepareLayerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UnprepareLayer(info hcsshim.DriverInfo, layerId string) error {
	fake.unprepareLayerMutex.Lock()
	ret, specificReturn := fake.unprepareLayerReturnsOnCall[len(fake.unprepareLayerArgsForCall)]
	fake.unprepareLayerArgsForCall = append(fake.unprepareLayerArgsForCall, struct {
		info    hcsshim.DriverInfo
		layerId string
	}{info, layerId})
	fake.recordInvocation("UnprepareLayer", []interface{}{info, layerId})
	fake.unprepareLayerMutex.Unlock()
	if fake.UnprepareLayerStub != nil {
		return fake.UnprepareLayerStub(info, layerId)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unprepareLayerReturns.result1
}

func (fake *FakeClient) UnprepareLayerCallCount() int {
	fake.unprepareLayerMutex.RLock()
	defer fake.unprepareLayerMutex.RUnlock()
	return len(fake.unprepareLayerArgsForCall)
}

func (fake *FakeClient) UnprepareLayerArgsForCall(i int) (hcsshim.DriverInfo, string) {
	fake.unprepareLayerMutex.RLock()
	defer fake.unprepareLayerMutex.RUnlock()
	return fake.unprepareLayerArgsForCall[i].info, fake.unprepareLayerArgsForCall[i].layerId
}

func (fake *FakeClient) UnprepareLayerReturns(result1 error) {
	fake.UnprepareLayerStub = nil
	fake.unprepareLayerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UnprepareLayerReturnsOnCall(i int, result1 error) {
	fake.UnprepareLayerStub = nil
	if fake.unprepareLayerReturnsOnCall == nil {
		fake.unprepareLayerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unprepareLayerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeactivateLayer(info hcsshim.DriverInfo, id string) error {
	fake.deactivateLayerMutex.Lock()
	ret, specificReturn := fake.deactivateLayerReturnsOnCall[len(fake.deactivateLayerArgsForCall)]
	fake.deactivateLayerArgsForCall = append(fake.deactivateLayerArgsForCall, struct {
		info hcsshim.DriverInfo
		id   string
	}{info, id})
	fake.recordInvocation("DeactivateLayer", []interface{}{info, id})
	fake.deactivateLayerMutex.Unlock()
	if fake.DeactivateLayerStub != nil {
		return fake.DeactivateLayerStub(info, id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deactivateLayerReturns.result1
}

func (fake *FakeClient) DeactivateLayerCallCount() int {
	fake.deactivateLayerMutex.RLock()
	defer fake.deactivateLayerMutex.RUnlock()
	return len(fake.deactivateLayerArgsForCall)
}

func (fake *FakeClient) DeactivateLayerArgsForCall(i int) (hcsshim.DriverInfo, string) {
	fake.deactivateLayerMutex.RLock()
	defer fake.deactivateLayerMutex.RUnlock()
	return fake.deactivateLayerArgsForCall[i].info, fake.deactivateLayerArgsForCall[i].id
}

func (fake *FakeClient) DeactivateLayerReturns(result1 error) {
	fake.DeactivateLayerStub = nil
	fake.deactivateLayerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeactivateLayerReturnsOnCall(i int, result1 error) {
	fake.DeactivateLayerStub = nil
	if fake.deactivateLayerReturnsOnCall == nil {
		fake.deactivateLayerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deactivateLayerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DestroyLayer(info hcsshim.DriverInfo, id string) error {
	fake.destroyLayerMutex.Lock()
	ret, specificReturn := fake.destroyLayerReturnsOnCall[len(fake.destroyLayerArgsForCall)]
	fake.destroyLayerArgsForCall = append(fake.destroyLayerArgsForCall, struct {
		info hcsshim.DriverInfo
		id   string
	}{info, id})
	fake.recordInvocation("DestroyLayer", []interface{}{info, id})
	fake.destroyLayerMutex.Unlock()
	if fake.DestroyLayerStub != nil {
		return fake.DestroyLayerStub(info, id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyLayerReturns.result1
}

func (fake *FakeClient) DestroyLayerCallCount() int {
	fake.destroyLayerMutex.RLock()
	defer fake.destroyLayerMutex.RUnlock()
	return len(fake.destroyLayerArgsForCall)
}

func (fake *FakeClient) DestroyLayerArgsForCall(i int) (hcsshim.DriverInfo, string) {
	fake.destroyLayerMutex.RLock()
	defer fake.destroyLayerMutex.RUnlock()
	return fake.destroyLayerArgsForCall[i].info, fake.destroyLayerArgsForCall[i].id
}

func (fake *FakeClient) DestroyLayerReturns(result1 error) {
	fake.DestroyLayerStub = nil
	fake.destroyLayerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DestroyLayerReturnsOnCall(i int, result1 error) {
	fake.DestroyLayerStub = nil
	if fake.destroyLayerReturnsOnCall == nil {
		fake.destroyLayerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyLayerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetContainerProperties(id string) (hcsshim.ContainerProperties, error) {
	fake.getContainerPropertiesMutex.Lock()
	ret, specificReturn := fake.getContainerPropertiesReturnsOnCall[len(fake.getContainerPropertiesArgsForCall)]
	fake.getContainerPropertiesArgsForCall = append(fake.getContainerPropertiesArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("GetContainerProperties", []interface{}{id})
	fake.getContainerPropertiesMutex.Unlock()
	if fake.GetContainerPropertiesStub != nil {
		return fake.GetContainerPropertiesStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getContainerPropertiesReturns.result1, fake.getContainerPropertiesReturns.result2
}

func (fake *FakeClient) GetContainerPropertiesCallCount() int {
	fake.getContainerPropertiesMutex.RLock()
	defer fake.getContainerPropertiesMutex.RUnlock()
	return len(fake.getContainerPropertiesArgsForCall)
}

func (fake *FakeClient) GetContainerPropertiesArgsForCall(i int) string {
	fake.getContainerPropertiesMutex.RLock()
	defer fake.getContainerPropertiesMutex.RUnlock()
	return fake.getContainerPropertiesArgsForCall[i].id
}

func (fake *FakeClient) GetContainerPropertiesReturns(result1 hcsshim.ContainerProperties, result2 error) {
	fake.GetContainerPropertiesStub = nil
	fake.getContainerPropertiesReturns = struct {
		result1 hcsshim.ContainerProperties
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetContainerPropertiesReturnsOnCall(i int, result1 hcsshim.ContainerProperties, result2 error) {
	fake.GetContainerPropertiesStub = nil
	if fake.getContainerPropertiesReturnsOnCall == nil {
		fake.getContainerPropertiesReturnsOnCall = make(map[int]struct {
			result1 hcsshim.ContainerProperties
			result2 error
		})
	}
	fake.getContainerPropertiesReturnsOnCall[i] = struct {
		result1 hcsshim.ContainerProperties
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) HNSListNetworkRequest() ([]hcsshim.HNSNetwork, error) {
	fake.hNSListNetworkRequestMutex.Lock()
	ret, specificReturn := fake.hNSListNetworkRequestReturnsOnCall[len(fake.hNSListNetworkRequestArgsForCall)]
	fake.hNSListNetworkRequestArgsForCall = append(fake.hNSListNetworkRequestArgsForCall, struct{}{})
	fake.recordInvocation("HNSListNetworkRequest", []interface{}{})
	fake.hNSListNetworkRequestMutex.Unlock()
	if fake.HNSListNetworkRequestStub != nil {
		return fake.HNSListNetworkRequestStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hNSListNetworkRequestReturns.result1, fake.hNSListNetworkRequestReturns.result2
}

func (fake *FakeClient) HNSListNetworkRequestCallCount() int {
	fake.hNSListNetworkRequestMutex.RLock()
	defer fake.hNSListNetworkRequestMutex.RUnlock()
	return len(fake.hNSListNetworkRequestArgsForCall)
}

func (fake *FakeClient) HNSListNetworkRequestReturns(result1 []hcsshim.HNSNetwork, result2 error) {
	fake.HNSListNetworkRequestStub = nil
	fake.hNSListNetworkRequestReturns = struct {
		result1 []hcsshim.HNSNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) HNSListNetworkRequestReturnsOnCall(i int, result1 []hcsshim.HNSNetwork, result2 error) {
	fake.HNSListNetworkRequestStub = nil
	if fake.hNSListNetworkRequestReturnsOnCall == nil {
		fake.hNSListNetworkRequestReturnsOnCall = make(map[int]struct {
			result1 []hcsshim.HNSNetwork
			result2 error
		})
	}
	fake.hNSListNetworkRequestReturnsOnCall[i] = struct {
		result1 []hcsshim.HNSNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetHNSEndpointByID(id string) (*hcsshim.HNSEndpoint, error) {
	fake.getHNSEndpointByIDMutex.Lock()
	ret, specificReturn := fake.getHNSEndpointByIDReturnsOnCall[len(fake.getHNSEndpointByIDArgsForCall)]
	fake.getHNSEndpointByIDArgsForCall = append(fake.getHNSEndpointByIDArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("GetHNSEndpointByID", []interface{}{id})
	fake.getHNSEndpointByIDMutex.Unlock()
	if fake.GetHNSEndpointByIDStub != nil {
		return fake.GetHNSEndpointByIDStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getHNSEndpointByIDReturns.result1, fake.getHNSEndpointByIDReturns.result2
}

func (fake *FakeClient) GetHNSEndpointByIDCallCount() int {
	fake.getHNSEndpointByIDMutex.RLock()
	defer fake.getHNSEndpointByIDMutex.RUnlock()
	return len(fake.getHNSEndpointByIDArgsForCall)
}

func (fake *FakeClient) GetHNSEndpointByIDArgsForCall(i int) string {
	fake.getHNSEndpointByIDMutex.RLock()
	defer fake.getHNSEndpointByIDMutex.RUnlock()
	return fake.getHNSEndpointByIDArgsForCall[i].id
}

func (fake *FakeClient) GetHNSEndpointByIDReturns(result1 *hcsshim.HNSEndpoint, result2 error) {
	fake.GetHNSEndpointByIDStub = nil
	fake.getHNSEndpointByIDReturns = struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetHNSEndpointByIDReturnsOnCall(i int, result1 *hcsshim.HNSEndpoint, result2 error) {
	fake.GetHNSEndpointByIDStub = nil
	if fake.getHNSEndpointByIDReturnsOnCall == nil {
		fake.getHNSEndpointByIDReturnsOnCall = make(map[int]struct {
			result1 *hcsshim.HNSEndpoint
			result2 error
		})
	}
	fake.getHNSEndpointByIDReturnsOnCall[i] = struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateEndpoint(arg1 *hcsshim.HNSEndpoint) (*hcsshim.HNSEndpoint, error) {
	fake.createEndpointMutex.Lock()
	ret, specificReturn := fake.createEndpointReturnsOnCall[len(fake.createEndpointArgsForCall)]
	fake.createEndpointArgsForCall = append(fake.createEndpointArgsForCall, struct {
		arg1 *hcsshim.HNSEndpoint
	}{arg1})
	fake.recordInvocation("CreateEndpoint", []interface{}{arg1})
	fake.createEndpointMutex.Unlock()
	if fake.CreateEndpointStub != nil {
		return fake.CreateEndpointStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createEndpointReturns.result1, fake.createEndpointReturns.result2
}

func (fake *FakeClient) CreateEndpointCallCount() int {
	fake.createEndpointMutex.RLock()
	defer fake.createEndpointMutex.RUnlock()
	return len(fake.createEndpointArgsForCall)
}

func (fake *FakeClient) CreateEndpointArgsForCall(i int) *hcsshim.HNSEndpoint {
	fake.createEndpointMutex.RLock()
	defer fake.createEndpointMutex.RUnlock()
	return fake.createEndpointArgsForCall[i].arg1
}

func (fake *FakeClient) CreateEndpointReturns(result1 *hcsshim.HNSEndpoint, result2 error) {
	fake.CreateEndpointStub = nil
	fake.createEndpointReturns = struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateEndpointReturnsOnCall(i int, result1 *hcsshim.HNSEndpoint, result2 error) {
	fake.CreateEndpointStub = nil
	if fake.createEndpointReturnsOnCall == nil {
		fake.createEndpointReturnsOnCall = make(map[int]struct {
			result1 *hcsshim.HNSEndpoint
			result2 error
		})
	}
	fake.createEndpointReturnsOnCall[i] = struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteEndpoint(arg1 *hcsshim.HNSEndpoint) (*hcsshim.HNSEndpoint, error) {
	fake.deleteEndpointMutex.Lock()
	ret, specificReturn := fake.deleteEndpointReturnsOnCall[len(fake.deleteEndpointArgsForCall)]
	fake.deleteEndpointArgsForCall = append(fake.deleteEndpointArgsForCall, struct {
		arg1 *hcsshim.HNSEndpoint
	}{arg1})
	fake.recordInvocation("DeleteEndpoint", []interface{}{arg1})
	fake.deleteEndpointMutex.Unlock()
	if fake.DeleteEndpointStub != nil {
		return fake.DeleteEndpointStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteEndpointReturns.result1, fake.deleteEndpointReturns.result2
}

func (fake *FakeClient) DeleteEndpointCallCount() int {
	fake.deleteEndpointMutex.RLock()
	defer fake.deleteEndpointMutex.RUnlock()
	return len(fake.deleteEndpointArgsForCall)
}

func (fake *FakeClient) DeleteEndpointArgsForCall(i int) *hcsshim.HNSEndpoint {
	fake.deleteEndpointMutex.RLock()
	defer fake.deleteEndpointMutex.RUnlock()
	return fake.deleteEndpointArgsForCall[i].arg1
}

func (fake *FakeClient) DeleteEndpointReturns(result1 *hcsshim.HNSEndpoint, result2 error) {
	fake.DeleteEndpointStub = nil
	fake.deleteEndpointReturns = struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteEndpointReturnsOnCall(i int, result1 *hcsshim.HNSEndpoint, result2 error) {
	fake.DeleteEndpointStub = nil
	if fake.deleteEndpointReturnsOnCall == nil {
		fake.deleteEndpointReturnsOnCall = make(map[int]struct {
			result1 *hcsshim.HNSEndpoint
			result2 error
		})
	}
	fake.deleteEndpointReturnsOnCall[i] = struct {
		result1 *hcsshim.HNSEndpoint
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateNetwork(arg1 *hcsshim.HNSNetwork) (*hcsshim.HNSNetwork, error) {
	fake.createNetworkMutex.Lock()
	ret, specificReturn := fake.createNetworkReturnsOnCall[len(fake.createNetworkArgsForCall)]
	fake.createNetworkArgsForCall = append(fake.createNetworkArgsForCall, struct {
		arg1 *hcsshim.HNSNetwork
	}{arg1})
	fake.recordInvocation("CreateNetwork", []interface{}{arg1})
	fake.createNetworkMutex.Unlock()
	if fake.CreateNetworkStub != nil {
		return fake.CreateNetworkStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createNetworkReturns.result1, fake.createNetworkReturns.result2
}

func (fake *FakeClient) CreateNetworkCallCount() int {
	fake.createNetworkMutex.RLock()
	defer fake.createNetworkMutex.RUnlock()
	return len(fake.createNetworkArgsForCall)
}

func (fake *FakeClient) CreateNetworkArgsForCall(i int) *hcsshim.HNSNetwork {
	fake.createNetworkMutex.RLock()
	defer fake.createNetworkMutex.RUnlock()
	return fake.createNetworkArgsForCall[i].arg1
}

func (fake *FakeClient) CreateNetworkReturns(result1 *hcsshim.HNSNetwork, result2 error) {
	fake.CreateNetworkStub = nil
	fake.createNetworkReturns = struct {
		result1 *hcsshim.HNSNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateNetworkReturnsOnCall(i int, result1 *hcsshim.HNSNetwork, result2 error) {
	fake.CreateNetworkStub = nil
	if fake.createNetworkReturnsOnCall == nil {
		fake.createNetworkReturnsOnCall = make(map[int]struct {
			result1 *hcsshim.HNSNetwork
			result2 error
		})
	}
	fake.createNetworkReturnsOnCall[i] = struct {
		result1 *hcsshim.HNSNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteNetwork(arg1 *hcsshim.HNSNetwork) (*hcsshim.HNSNetwork, error) {
	fake.deleteNetworkMutex.Lock()
	ret, specificReturn := fake.deleteNetworkReturnsOnCall[len(fake.deleteNetworkArgsForCall)]
	fake.deleteNetworkArgsForCall = append(fake.deleteNetworkArgsForCall, struct {
		arg1 *hcsshim.HNSNetwork
	}{arg1})
	fake.recordInvocation("DeleteNetwork", []interface{}{arg1})
	fake.deleteNetworkMutex.Unlock()
	if fake.DeleteNetworkStub != nil {
		return fake.DeleteNetworkStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteNetworkReturns.result1, fake.deleteNetworkReturns.result2
}

func (fake *FakeClient) DeleteNetworkCallCount() int {
	fake.deleteNetworkMutex.RLock()
	defer fake.deleteNetworkMutex.RUnlock()
	return len(fake.deleteNetworkArgsForCall)
}

func (fake *FakeClient) DeleteNetworkArgsForCall(i int) *hcsshim.HNSNetwork {
	fake.deleteNetworkMutex.RLock()
	defer fake.deleteNetworkMutex.RUnlock()
	return fake.deleteNetworkArgsForCall[i].arg1
}

func (fake *FakeClient) DeleteNetworkReturns(result1 *hcsshim.HNSNetwork, result2 error) {
	fake.DeleteNetworkStub = nil
	fake.deleteNetworkReturns = struct {
		result1 *hcsshim.HNSNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteNetworkReturnsOnCall(i int, result1 *hcsshim.HNSNetwork, result2 error) {
	fake.DeleteNetworkStub = nil
	if fake.deleteNetworkReturnsOnCall == nil {
		fake.deleteNetworkReturnsOnCall = make(map[int]struct {
			result1 *hcsshim.HNSNetwork
			result2 error
		})
	}
	fake.deleteNetworkReturnsOnCall[i] = struct {
		result1 *hcsshim.HNSNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getContainersMutex.RLock()
	defer fake.getContainersMutex.RUnlock()
	fake.nameToGuidMutex.RLock()
	defer fake.nameToGuidMutex.RUnlock()
	fake.getLayerMountPathMutex.RLock()
	defer fake.getLayerMountPathMutex.RUnlock()
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	fake.openContainerMutex.RLock()
	defer fake.openContainerMutex.RUnlock()
	fake.isPendingMutex.RLock()
	defer fake.isPendingMutex.RUnlock()
	fake.createSandboxLayerMutex.RLock()
	defer fake.createSandboxLayerMutex.RUnlock()
	fake.activateLayerMutex.RLock()
	defer fake.activateLayerMutex.RUnlock()
	fake.prepareLayerMutex.RLock()
	defer fake.prepareLayerMutex.RUnlock()
	fake.unprepareLayerMutex.RLock()
	defer fake.unprepareLayerMutex.RUnlock()
	fake.deactivateLayerMutex.RLock()
	defer fake.deactivateLayerMutex.RUnlock()
	fake.destroyLayerMutex.RLock()
	defer fake.destroyLayerMutex.RUnlock()
	fake.getContainerPropertiesMutex.RLock()
	defer fake.getContainerPropertiesMutex.RUnlock()
	fake.hNSListNetworkRequestMutex.RLock()
	defer fake.hNSListNetworkRequestMutex.RUnlock()
	fake.getHNSEndpointByIDMutex.RLock()
	defer fake.getHNSEndpointByIDMutex.RUnlock()
	fake.createEndpointMutex.RLock()
	defer fake.createEndpointMutex.RUnlock()
	fake.deleteEndpointMutex.RLock()
	defer fake.deleteEndpointMutex.RUnlock()
	fake.createNetworkMutex.RLock()
	defer fake.createNetworkMutex.RUnlock()
	fake.deleteNetworkMutex.RLock()
	defer fake.deleteNetworkMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ hcsclient.Client = new(FakeClient)
