// This file was generated by counterfeiter
package containerfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/winc/container"
	"github.com/Microsoft/hcsshim"
)

type FakeHCSContainer struct {
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct{}
	startReturns     struct {
		result1 error
	}
	ShutdownStub        func() error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct{}
	shutdownReturns     struct {
		result1 error
	}
	TerminateStub        func() error
	terminateMutex       sync.RWMutex
	terminateArgsForCall []struct{}
	terminateReturns     struct {
		result1 error
	}
	WaitStub        func() error
	waitMutex       sync.RWMutex
	waitArgsForCall []struct{}
	waitReturns     struct {
		result1 error
	}
	WaitTimeoutStub        func(time.Duration) error
	waitTimeoutMutex       sync.RWMutex
	waitTimeoutArgsForCall []struct {
		arg1 time.Duration
	}
	waitTimeoutReturns struct {
		result1 error
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct{}
	pauseReturns     struct {
		result1 error
	}
	ResumeStub        func() error
	resumeMutex       sync.RWMutex
	resumeArgsForCall []struct{}
	resumeReturns     struct {
		result1 error
	}
	HasPendingUpdatesStub        func() (bool, error)
	hasPendingUpdatesMutex       sync.RWMutex
	hasPendingUpdatesArgsForCall []struct{}
	hasPendingUpdatesReturns     struct {
		result1 bool
		result2 error
	}
	StatisticsStub        func() (hcsshim.Statistics, error)
	statisticsMutex       sync.RWMutex
	statisticsArgsForCall []struct{}
	statisticsReturns     struct {
		result1 hcsshim.Statistics
		result2 error
	}
	ProcessListStub        func() ([]hcsshim.ProcessListItem, error)
	processListMutex       sync.RWMutex
	processListArgsForCall []struct{}
	processListReturns     struct {
		result1 []hcsshim.ProcessListItem
		result2 error
	}
	CreateProcessStub        func(c *hcsshim.ProcessConfig) (hcsshim.Process, error)
	createProcessMutex       sync.RWMutex
	createProcessArgsForCall []struct {
		c *hcsshim.ProcessConfig
	}
	createProcessReturns struct {
		result1 hcsshim.Process
		result2 error
	}
	OpenProcessStub        func(pid int) (hcsshim.Process, error)
	openProcessMutex       sync.RWMutex
	openProcessArgsForCall []struct {
		pid int
	}
	openProcessReturns struct {
		result1 hcsshim.Process
		result2 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct{}
	closeReturns     struct {
		result1 error
	}
	ModifyStub        func(config *hcsshim.ResourceModificationRequestResponse) error
	modifyMutex       sync.RWMutex
	modifyArgsForCall []struct {
		config *hcsshim.ResourceModificationRequestResponse
	}
	modifyReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeHCSContainer) Start() error {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct{}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	} else {
		return fake.startReturns.result1
	}
}

func (fake *FakeHCSContainer) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeHCSContainer) StartReturns(result1 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHCSContainer) Shutdown() error {
	fake.shutdownMutex.Lock()
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct{}{})
	fake.recordInvocation("Shutdown", []interface{}{})
	fake.shutdownMutex.Unlock()
	if fake.ShutdownStub != nil {
		return fake.ShutdownStub()
	} else {
		return fake.shutdownReturns.result1
	}
}

func (fake *FakeHCSContainer) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeHCSContainer) ShutdownReturns(result1 error) {
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHCSContainer) Terminate() error {
	fake.terminateMutex.Lock()
	fake.terminateArgsForCall = append(fake.terminateArgsForCall, struct{}{})
	fake.recordInvocation("Terminate", []interface{}{})
	fake.terminateMutex.Unlock()
	if fake.TerminateStub != nil {
		return fake.TerminateStub()
	} else {
		return fake.terminateReturns.result1
	}
}

func (fake *FakeHCSContainer) TerminateCallCount() int {
	fake.terminateMutex.RLock()
	defer fake.terminateMutex.RUnlock()
	return len(fake.terminateArgsForCall)
}

func (fake *FakeHCSContainer) TerminateReturns(result1 error) {
	fake.TerminateStub = nil
	fake.terminateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHCSContainer) Wait() error {
	fake.waitMutex.Lock()
	fake.waitArgsForCall = append(fake.waitArgsForCall, struct{}{})
	fake.recordInvocation("Wait", []interface{}{})
	fake.waitMutex.Unlock()
	if fake.WaitStub != nil {
		return fake.WaitStub()
	} else {
		return fake.waitReturns.result1
	}
}

func (fake *FakeHCSContainer) WaitCallCount() int {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	return len(fake.waitArgsForCall)
}

func (fake *FakeHCSContainer) WaitReturns(result1 error) {
	fake.WaitStub = nil
	fake.waitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHCSContainer) WaitTimeout(arg1 time.Duration) error {
	fake.waitTimeoutMutex.Lock()
	fake.waitTimeoutArgsForCall = append(fake.waitTimeoutArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("WaitTimeout", []interface{}{arg1})
	fake.waitTimeoutMutex.Unlock()
	if fake.WaitTimeoutStub != nil {
		return fake.WaitTimeoutStub(arg1)
	} else {
		return fake.waitTimeoutReturns.result1
	}
}

func (fake *FakeHCSContainer) WaitTimeoutCallCount() int {
	fake.waitTimeoutMutex.RLock()
	defer fake.waitTimeoutMutex.RUnlock()
	return len(fake.waitTimeoutArgsForCall)
}

func (fake *FakeHCSContainer) WaitTimeoutArgsForCall(i int) time.Duration {
	fake.waitTimeoutMutex.RLock()
	defer fake.waitTimeoutMutex.RUnlock()
	return fake.waitTimeoutArgsForCall[i].arg1
}

func (fake *FakeHCSContainer) WaitTimeoutReturns(result1 error) {
	fake.WaitTimeoutStub = nil
	fake.waitTimeoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHCSContainer) Pause() error {
	fake.pauseMutex.Lock()
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct{}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	} else {
		return fake.pauseReturns.result1
	}
}

func (fake *FakeHCSContainer) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakeHCSContainer) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHCSContainer) Resume() error {
	fake.resumeMutex.Lock()
	fake.resumeArgsForCall = append(fake.resumeArgsForCall, struct{}{})
	fake.recordInvocation("Resume", []interface{}{})
	fake.resumeMutex.Unlock()
	if fake.ResumeStub != nil {
		return fake.ResumeStub()
	} else {
		return fake.resumeReturns.result1
	}
}

func (fake *FakeHCSContainer) ResumeCallCount() int {
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	return len(fake.resumeArgsForCall)
}

func (fake *FakeHCSContainer) ResumeReturns(result1 error) {
	fake.ResumeStub = nil
	fake.resumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHCSContainer) HasPendingUpdates() (bool, error) {
	fake.hasPendingUpdatesMutex.Lock()
	fake.hasPendingUpdatesArgsForCall = append(fake.hasPendingUpdatesArgsForCall, struct{}{})
	fake.recordInvocation("HasPendingUpdates", []interface{}{})
	fake.hasPendingUpdatesMutex.Unlock()
	if fake.HasPendingUpdatesStub != nil {
		return fake.HasPendingUpdatesStub()
	} else {
		return fake.hasPendingUpdatesReturns.result1, fake.hasPendingUpdatesReturns.result2
	}
}

func (fake *FakeHCSContainer) HasPendingUpdatesCallCount() int {
	fake.hasPendingUpdatesMutex.RLock()
	defer fake.hasPendingUpdatesMutex.RUnlock()
	return len(fake.hasPendingUpdatesArgsForCall)
}

func (fake *FakeHCSContainer) HasPendingUpdatesReturns(result1 bool, result2 error) {
	fake.HasPendingUpdatesStub = nil
	fake.hasPendingUpdatesReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeHCSContainer) Statistics() (hcsshim.Statistics, error) {
	fake.statisticsMutex.Lock()
	fake.statisticsArgsForCall = append(fake.statisticsArgsForCall, struct{}{})
	fake.recordInvocation("Statistics", []interface{}{})
	fake.statisticsMutex.Unlock()
	if fake.StatisticsStub != nil {
		return fake.StatisticsStub()
	} else {
		return fake.statisticsReturns.result1, fake.statisticsReturns.result2
	}
}

func (fake *FakeHCSContainer) StatisticsCallCount() int {
	fake.statisticsMutex.RLock()
	defer fake.statisticsMutex.RUnlock()
	return len(fake.statisticsArgsForCall)
}

func (fake *FakeHCSContainer) StatisticsReturns(result1 hcsshim.Statistics, result2 error) {
	fake.StatisticsStub = nil
	fake.statisticsReturns = struct {
		result1 hcsshim.Statistics
		result2 error
	}{result1, result2}
}

func (fake *FakeHCSContainer) ProcessList() ([]hcsshim.ProcessListItem, error) {
	fake.processListMutex.Lock()
	fake.processListArgsForCall = append(fake.processListArgsForCall, struct{}{})
	fake.recordInvocation("ProcessList", []interface{}{})
	fake.processListMutex.Unlock()
	if fake.ProcessListStub != nil {
		return fake.ProcessListStub()
	} else {
		return fake.processListReturns.result1, fake.processListReturns.result2
	}
}

func (fake *FakeHCSContainer) ProcessListCallCount() int {
	fake.processListMutex.RLock()
	defer fake.processListMutex.RUnlock()
	return len(fake.processListArgsForCall)
}

func (fake *FakeHCSContainer) ProcessListReturns(result1 []hcsshim.ProcessListItem, result2 error) {
	fake.ProcessListStub = nil
	fake.processListReturns = struct {
		result1 []hcsshim.ProcessListItem
		result2 error
	}{result1, result2}
}

func (fake *FakeHCSContainer) CreateProcess(c *hcsshim.ProcessConfig) (hcsshim.Process, error) {
	fake.createProcessMutex.Lock()
	fake.createProcessArgsForCall = append(fake.createProcessArgsForCall, struct {
		c *hcsshim.ProcessConfig
	}{c})
	fake.recordInvocation("CreateProcess", []interface{}{c})
	fake.createProcessMutex.Unlock()
	if fake.CreateProcessStub != nil {
		return fake.CreateProcessStub(c)
	} else {
		return fake.createProcessReturns.result1, fake.createProcessReturns.result2
	}
}

func (fake *FakeHCSContainer) CreateProcessCallCount() int {
	fake.createProcessMutex.RLock()
	defer fake.createProcessMutex.RUnlock()
	return len(fake.createProcessArgsForCall)
}

func (fake *FakeHCSContainer) CreateProcessArgsForCall(i int) *hcsshim.ProcessConfig {
	fake.createProcessMutex.RLock()
	defer fake.createProcessMutex.RUnlock()
	return fake.createProcessArgsForCall[i].c
}

func (fake *FakeHCSContainer) CreateProcessReturns(result1 hcsshim.Process, result2 error) {
	fake.CreateProcessStub = nil
	fake.createProcessReturns = struct {
		result1 hcsshim.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeHCSContainer) OpenProcess(pid int) (hcsshim.Process, error) {
	fake.openProcessMutex.Lock()
	fake.openProcessArgsForCall = append(fake.openProcessArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("OpenProcess", []interface{}{pid})
	fake.openProcessMutex.Unlock()
	if fake.OpenProcessStub != nil {
		return fake.OpenProcessStub(pid)
	} else {
		return fake.openProcessReturns.result1, fake.openProcessReturns.result2
	}
}

func (fake *FakeHCSContainer) OpenProcessCallCount() int {
	fake.openProcessMutex.RLock()
	defer fake.openProcessMutex.RUnlock()
	return len(fake.openProcessArgsForCall)
}

func (fake *FakeHCSContainer) OpenProcessArgsForCall(i int) int {
	fake.openProcessMutex.RLock()
	defer fake.openProcessMutex.RUnlock()
	return fake.openProcessArgsForCall[i].pid
}

func (fake *FakeHCSContainer) OpenProcessReturns(result1 hcsshim.Process, result2 error) {
	fake.OpenProcessStub = nil
	fake.openProcessReturns = struct {
		result1 hcsshim.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeHCSContainer) Close() error {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	} else {
		return fake.closeReturns.result1
	}
}

func (fake *FakeHCSContainer) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeHCSContainer) CloseReturns(result1 error) {
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHCSContainer) Modify(config *hcsshim.ResourceModificationRequestResponse) error {
	fake.modifyMutex.Lock()
	fake.modifyArgsForCall = append(fake.modifyArgsForCall, struct {
		config *hcsshim.ResourceModificationRequestResponse
	}{config})
	fake.recordInvocation("Modify", []interface{}{config})
	fake.modifyMutex.Unlock()
	if fake.ModifyStub != nil {
		return fake.ModifyStub(config)
	} else {
		return fake.modifyReturns.result1
	}
}

func (fake *FakeHCSContainer) ModifyCallCount() int {
	fake.modifyMutex.RLock()
	defer fake.modifyMutex.RUnlock()
	return len(fake.modifyArgsForCall)
}

func (fake *FakeHCSContainer) ModifyArgsForCall(i int) *hcsshim.ResourceModificationRequestResponse {
	fake.modifyMutex.RLock()
	defer fake.modifyMutex.RUnlock()
	return fake.modifyArgsForCall[i].config
}

func (fake *FakeHCSContainer) ModifyReturns(result1 error) {
	fake.ModifyStub = nil
	fake.modifyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeHCSContainer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.terminateMutex.RLock()
	defer fake.terminateMutex.RUnlock()
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	fake.waitTimeoutMutex.RLock()
	defer fake.waitTimeoutMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	fake.hasPendingUpdatesMutex.RLock()
	defer fake.hasPendingUpdatesMutex.RUnlock()
	fake.statisticsMutex.RLock()
	defer fake.statisticsMutex.RUnlock()
	fake.processListMutex.RLock()
	defer fake.processListMutex.RUnlock()
	fake.createProcessMutex.RLock()
	defer fake.createProcessMutex.RUnlock()
	fake.openProcessMutex.RLock()
	defer fake.openProcessMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.modifyMutex.RLock()
	defer fake.modifyMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeHCSContainer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ container.HCSContainer = new(FakeHCSContainer)
